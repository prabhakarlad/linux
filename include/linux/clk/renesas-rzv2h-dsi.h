/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Renesas RZ/V2H(P) DSI CPG helper
 *
 * Copyright (C) 2025 Renesas Electronics Corp.
 */

#include <linux/limits.h>
#include <linux/math.h>
#include <linux/math64.h>
#include <linux/units.h>

#define OSC_CLK_IN_MEGA		(24 * MEGA)

struct rzv2h_plldsi_div_limits {
	struct {
		u64 min;
		u64 max;
	} fvco;

	struct {
		u16 min;
		u16 max;
	} m;

	struct {
		u8 min;
		u8 max;
	} p;

	struct {
		u8 min;
		u8 max;
	} s;

	struct {
		s16 min;
		s16 max;
	} k;

	struct {
		u8 min;
		u8 max;
	} csdiv;
};

struct rzv2h_plldsi_parameters {
	u64 freq_mhz;
	s64 error_mhz;
	u16 m;
	s16 k;
	u8 csdiv;
	u8 p;
	u8 s;
};

#define RZV2H_CPG_PLL_DSI_LIMITS(name)					\
	static const struct rzv2h_plldsi_div_limits (name) = {		\
		.m = { .min = 64, .max = 533 },				\
		.p = { .min = 1, .max = 4 },				\
		.s = { .min = 0, .max = 6 },				\
		.k = { .min = -32768, .max = 32767 },			\
		.csdiv = { .min = 2, .max = 32 },			\
		.fvco = { .min = 1600 * MEGA, .max = 3200 * MEGA }	\
	}								\

/**
 * rzv2h_dsi_get_pll_parameters_values - Finds the best combination of PLL parameters
 * and divider value for a given frequency.
 *
 * @limits: Pointer to the structure containing the limits for the PLL parameters and
 * divider values
 * @pars: Pointer to the structure where the best calculated PLL parameters and divider
 * values will be stored
 * @freq: Target output frequency (in mHz)
 *
 * This function calculates the best set of PLL parameters (M, K, P, S) and divider
 * value (CSDIV) to achieve the desired frequency.
 * There is no direct formula to calculate the PLL parameters and the divider value,
 * as it's an open system of equations, therefore this function uses an iterative
 * approach to determine the best solution. The best solution is one that minimizes
 * the error (desired frequency - actual frequency).
 *
 * Return: true if a valid set of divider values is found, false otherwise.
 */
static __maybe_unused bool
rzv2h_dsi_get_pll_parameters_values(const struct rzv2h_plldsi_div_limits *limits,
				    struct rzv2h_plldsi_parameters *pars,
				    u64 freq_mhz)
{
	struct rzv2h_plldsi_parameters p, best;

	/* Initialize best error to maximum possible value */
	best.error_mhz = S64_MAX;

	for (p.csdiv = limits->csdiv.min; p.csdiv <= limits->csdiv.max; p.csdiv += 2) {
		for (p.p = limits->p.min; p.p <= limits->p.max; p.p++) {
			u32 fref = OSC_CLK_IN_MEGA / p.p;

			for (p.s = limits->s.min; p.s <= limits->s.max; p.s++) {
				u16 two_pow_s = 1 << p.s;
				u16 divider = two_pow_s * p.csdiv;

				for (p.m = limits->m.min; p.m <= limits->m.max; p.m++) {
					u64 output_m, output_k_range;
					s64 pll_k, output_k;
					u64 fvco, output;

					/*
					 * The frequency generated by the combination of the
					 * PLL + divider is calculated as follows:
					 *
					 * Freq = Ffout / csdiv
					 *
					 * With:
					 * Ffout = Ffvco / 2^(pll_s)
					 * Ffvco = (pll_m + (pll_k / 65536)) * Ffref
					 * Ffref = 24MHz / pll_p
					 *
					 * Freq can also be rewritten as:
					 * Freq = Ffvco / (2^(pll_s) * csdiv))
					 *      = Ffvco / divider
					 *      = (pll_m * Ffref) / divider + ((pll_k / 65536) * Ffref) / divider
					 *      = output_m + output_k
					 *
					 * Every parameter has been determined at this point, but pll_k.
					 * Considering that:
					 * -32768 <= pll_k <= 32767
					 * Then:
					 * -0.5 <= (pll_k / 65536) < 0.5
					 * Therefore:
					 * -Ffref / (2 * divider) <= output_k < Ffref / (2 * divider)
					 */

					/* Compute output M component (in mHz) */
					output_m = DIV_ROUND_CLOSEST_ULL(p.m * fref * 1000ULL,
									 divider);
					/* Compute range for output K (in mHz) */
					output_k_range = DIV_ROUND_CLOSEST_ULL(fref * 1000ULL,
									       divider * 2);
					/*
					 * No point in continuing if we can't achieve the
					 * desired frequency
					 */
					if (freq_mhz <  (output_m - output_k_range) ||
					    freq_mhz >= (output_m + output_k_range))
						continue;

					/*
					 * Compute the K component
					 *
					 * Since:
					 * Freq = output_m + output_k
					 * Then:
					 * output_k = Freq - output_m
					 *          = ((pll_k / 65536) * Ffref) / divider
					 * Therefore:
					 * pll_k = (output_k * 65536 * divider) / Ffref
					 */
					output_k = freq_mhz - output_m;
					pll_k = div64_s64(output_k * 65536ULL * divider, fref);
					pll_k = DIV_S64_ROUND_CLOSEST(pll_k, 1000);

					/* Validate K value within allowed limits */
					if (pll_k < limits->k.min || pll_k > limits->k.max)
						continue;

					p.k = pll_k;

					/* Compute (Ffvco * 65536) */
					fvco = ((p.m * 65536ULL) + p.k) * fref;
					if ((fvco < (limits->fvco.min * 65536ULL)) ||
					    (fvco > (limits->fvco.max * 65536ULL)))
						continue;

					/* PLL_M component of (output * 65536 * PLL_P) */
					output = p.m * 65536ULL * OSC_CLK_IN_MEGA;
					/* PLL_K component of (output * 65536 * PLL_P) */
					output += p.k * OSC_CLK_IN_MEGA;
					/* Make it in mHz */
					output *= 1000ULL;
					output /= 65536ULL * p.p * divider;

					p.error_mhz = freq_mhz - output;
					p.freq_mhz = output;

					/* If an exact match is found, return immediately */
					if (p.error_mhz == 0) {
						*pars = p;
						return true;
					}

					/* Update best match if error is smaller */
					if (abs(best.error_mhz) > abs(p.error_mhz))
						best = p;
				}
			}
		}
	}

	/* If no valid parameters were found, return false */
	if (best.error_mhz == S64_MAX)
		return false;

	*pars = best;
	return true;
}
